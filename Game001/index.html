<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Cube Othello</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
  width: 100%;
  height: 100%;
  height: 100dvh;
  overflow: hidden;
  touch-action: none;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background: #1a1a2e;
  color: #e0e0e0;
  display: flex;
  flex-direction: column;
  align-items: center;
  user-select: none;
  padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
}

h1 {
  font-size: clamp(20px, 5vw, 32px);
  letter-spacing: 3px;
  color: #e94560;
  margin-top: 8px;
  flex-shrink: 0;
}

#info-bar {
  display: flex;
  gap: clamp(12px, 4vw, 32px);
  align-items: center;
  margin: 6px 0 2px;
  font-size: clamp(14px, 3.5vw, 20px);
  flex-shrink: 0;
}

#info-bar .score {
  display: flex;
  align-items: center;
  gap: 6px;
}

#info-bar .piece-icon {
  width: clamp(16px, 3.5vw, 22px);
  height: clamp(16px, 3.5vw, 22px);
  border-radius: 50%;
  display: inline-block;
  border: 1px solid #888;
}

#info-bar .piece-icon.black { background: #222; }
#info-bar .piece-icon.white { background: #eee; }

#turn-indicator {
  font-weight: bold;
  color: #e94560;
}

#message {
  height: 28px;
  line-height: 28px;
  font-size: clamp(13px, 3vw, 18px);
  color: #ffd700;
  text-align: center;
  flex-shrink: 0;
}

#scene {
  flex: 1 1 auto;
  width: 100%;
  max-width: 520px;
  perspective: 1100px;
  cursor: grab;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 0;
}

#scene:active { cursor: grabbing; }

#cube-container {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

#cube {
  /* サイズはJSで動的に設定 */
  width: 240px;
  height: 240px;
  position: relative;
  transform-style: preserve-3d;
  transition: transform 0.05s linear;
}

.face {
  position: absolute;
  width: var(--face-size, 240px);
  height: var(--face-size, 240px);
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: 1fr 1fr;
  gap: 3px;
  padding: 3px;
  backface-visibility: visible;
  border: 2px solid rgba(255,255,255,0.15);
  border-radius: 6px;
  pointer-events: none;
}

.face-top    { background: rgba(76, 175, 80, 0.85); transform: rotateX(90deg)  translateZ(var(--half-face, 120px)); }
.face-bottom { background: rgba(76, 175, 80, 0.85); transform: rotateX(-90deg) translateZ(var(--half-face, 120px)); }
.face-front  { background: rgba(56, 142, 60, 0.85); transform:                 translateZ(var(--half-face, 120px)); }
.face-back   { background: rgba(56, 142, 60, 0.85); transform: rotateY(180deg) translateZ(var(--half-face, 120px)); }
.face-right  { background: rgba(67, 160, 71, 0.85); transform: rotateY(90deg)  translateZ(var(--half-face, 120px)); }
.face-left   { background: rgba(67, 160, 71, 0.85); transform: rotateY(-90deg) translateZ(var(--half-face, 120px)); }

.face-label {
  position: absolute;
  top: -18px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 10px;
  color: rgba(255,255,255,0.5);
  pointer-events: none;
}

.cell {
  background: rgba(0, 0, 0, 0.15);
  border-radius: 5px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: default;
  position: relative;
  transition: background 0.15s;
  pointer-events: none;
}

.cell.clickable {
  pointer-events: auto;
  cursor: pointer;
}

.cell.clickable:hover {
  background: rgba(255, 255, 255, 0.25);
}

.cell .piece {
  width: 60%;
  height: 60%;
  border-radius: 50%;
  transition: transform 0.3s, background 0.3s;
  box-shadow: 0 2px 6px rgba(0,0,0,0.5);
}

.cell .piece.black {
  background: radial-gradient(circle at 35% 35%, #555, #111);
}

.cell .piece.white {
  background: radial-gradient(circle at 35% 35%, #fff, #ccc);
}

.cell .piece.flipping {
  animation: flip-anim 0.4s ease-in-out;
}

@keyframes flip-anim {
  0%   { transform: rotateY(0deg); }
  50%  { transform: rotateY(90deg); }
  100% { transform: rotateY(0deg); }
}

.cell .valid-marker {
  width: 30%;
  height: 30%;
  border-radius: 50%;
  background: rgba(255, 215, 0, 0.5);
  animation: pulse 1.2s infinite;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); opacity: 0.5; }
  50%      { transform: scale(1.3); opacity: 0.8; }
}

#controls {
  margin: 6px 0;
  display: flex;
  gap: 10px;
  flex-shrink: 0;
}

button {
  padding: 8px 20px;
  border: none;
  border-radius: 5px;
  background: #e94560;
  color: white;
  font-size: clamp(13px, 3vw, 16px);
  cursor: pointer;
  transition: background 0.2s;
}

button:hover { background: #c73650; }
button:disabled { background: #666; cursor: not-allowed; }

#help-text {
  margin-bottom: 8px;
  font-size: clamp(11px, 2.5vw, 14px);
  color: #888;
  text-align: center;
  line-height: 1.5;
  padding: 0 12px;
  flex-shrink: 0;
}
</style>
</head>
<body>

<h1>CUBE OTHELLO</h1>

<div id="info-bar">
  <div class="score"><span class="piece-icon black"></span> あなた: <span id="score-black">2</span></div>
  <div id="turn-indicator">あなたの番</div>
  <div class="score"><span class="piece-icon white"></span> CPU: <span id="score-white">2</span></div>
</div>

<div id="message"></div>

<div id="scene">
  <div id="cube-container">
    <div id="cube"></div>
  </div>
</div>

<div id="controls">
  <button id="btn-new">新しいゲーム</button>
  <button id="btn-reset-view">視点リセット</button>
</div>

<div id="help-text">
  ドラッグでキューブを回転。金色のマーカーをクリックして石を置きます。<br>
  斜め方向を含め、面をまたいで石をひっくり返せます。
</div>

<script>
// =======================================================
// CUBE OTHELLO - Complete Implementation
// =======================================================

// -------------------------------------------------------
// 1. CUBE TOPOLOGY
// -------------------------------------------------------
// Faces: 0=Top, 1=Front, 2=Right, 3=Back, 4=Left, 5=Bottom
// Each face has a 2x2 grid: cells (0,0) (0,1) (1,0) (1,1)
//
// Face orientations (looking at each face from outside the cube):
//
// Top (face 0): looking down from above
//   North = Back edge, South = Front edge, West = Left edge, East = Right edge
//   (0,0)=back-left  (0,1)=back-right
//   (1,0)=front-left (1,1)=front-right
//
// Front (face 1): looking straight at front
//   North = Top edge, South = Bottom edge, West = Left edge, East = Right edge
//   (0,0)=top-left    (0,1)=top-right
//   (1,0)=bottom-left (1,1)=bottom-right
//
// Right (face 2): looking at right side
//   North = Top edge, South = Bottom edge, West = Front edge, East = Back edge
//   (0,0)=top-front    (0,1)=top-back
//   (1,0)=bottom-front (1,1)=bottom-back
//
// Back (face 3): looking at back from behind the cube
//   North = Top edge, South = Bottom edge, West = Right edge, East = Left edge
//   (0,0)=top-right   (0,1)=top-left
//   (1,0)=bottom-right(1,1)=bottom-left
//
// Left (face 4): looking at left side
//   North = Top edge, South = Bottom edge, West = Back edge, East = Front edge
//   (0,0)=top-back    (0,1)=top-front
//   (1,0)=bottom-back (1,1)=bottom-front
//
// Bottom (face 5): looking up from below
//   North = Front edge, South = Back edge, West = Left edge, East = Right edge
//   (0,0)=front-left  (0,1)=front-right
//   (1,0)=back-left   (1,1)=back-right

const FACE_NAMES = ['Top', 'Front', 'Right', 'Back', 'Left', 'Bottom'];
const TOP = 0, FRONT = 1, RIGHT = 2, BACK = 3, LEFT = 4, BOTTOM = 5;

// Direction vectors: [dr, dc]
const DIRS = [
  [-1, 0],  // N
  [-1, 1],  // NE
  [0, 1],   // E
  [1, 1],   // SE
  [1, 0],   // S
  [1, -1],  // SW
  [0, -1],  // W
  [-1, -1], // NW
];

// Edge transition table.
// Key: "fromFace,edge" where edge is 'N','E','S','W'
// Value: { toFace, mapPos(edgeIdx) -> [row,col], mapDir(dr,dc) -> [dr,dc] }
// edgeIdx is the position along the edge (0 or 1):
//   N edge: col 0, col 1 (row=0)
//   S edge: col 0, col 1 (row=1)
//   W edge: row 0, row 1 (col=0)
//   E edge: row 0, row 1 (col=1)

// Build the edge transition table based on 3D geometry analysis.
// For each face, define what happens when you go off each edge.

const EDGE_TRANSITIONS = {
  // === TOP face (0) edges ===
  // Top-N -> Back: Top(0,0)@(-0.25,1,-0.25)->Back(0,1), Top(0,1)@(0.25,1,-0.25)->Back(0,0)
  '0,N': { toFace: BACK, mapPos: c => [0, 1 - c], mapDir: (dr, dc) => [-dr, -dc] },
  // Top-S -> Front: Top(1,0)->Front(0,0), Top(1,1)->Front(0,1)
  '0,S': { toFace: FRONT, mapPos: c => [0, c], mapDir: (dr, dc) => [dr, dc] },
  // Top-W -> Left: Top(0,0)->Left(0,0), Top(1,0)->Left(0,1)
  '0,W': { toFace: LEFT, mapPos: r => [0, r], mapDir: (dr, dc) => [-dc, dr] },
  // Top-E -> Right: Top(0,1)->Right(0,1), Top(1,1)->Right(0,0)
  '0,E': { toFace: RIGHT, mapPos: r => [0, 1 - r], mapDir: (dr, dc) => [dc, -dr] },

  // === FRONT face (1) edges ===
  // Front-N -> Top: Front(0,0)->Top(1,0), Front(0,1)->Top(1,1)
  '1,N': { toFace: TOP, mapPos: c => [1, c], mapDir: (dr, dc) => [dr, dc] },
  // Front-S -> Bottom: Front(1,0)->Bottom(0,0), Front(1,1)->Bottom(0,1)
  '1,S': { toFace: BOTTOM, mapPos: c => [0, c], mapDir: (dr, dc) => [dr, dc] },
  // Front-W -> Left: Front(0,0)->Left(0,1), Front(1,0)->Left(1,1)
  '1,W': { toFace: LEFT, mapPos: r => [r, 1], mapDir: (dr, dc) => [dr, dc] },
  // Front-E -> Right: Front(0,1)->Right(0,0), Front(1,1)->Right(1,0)
  '1,E': { toFace: RIGHT, mapPos: r => [r, 0], mapDir: (dr, dc) => [dr, dc] },

  // === RIGHT face (2) edges ===
  // Right-N -> Top: Right(0,0)->Top(1,1), Right(0,1)->Top(0,1)
  '2,N': { toFace: TOP, mapPos: c => [1 - c, 1], mapDir: (dr, dc) => [-dc, dr] },
  // Right-S -> Bottom: Right(1,0)->Bottom(0,1), Right(1,1)->Bottom(1,1)
  '2,S': { toFace: BOTTOM, mapPos: c => [c, 1], mapDir: (dr, dc) => [dc, -dr] },
  // Right-W -> Front: Right(0,0)->Front(0,1), Right(1,0)->Front(1,1)
  '2,W': { toFace: FRONT, mapPos: r => [r, 1], mapDir: (dr, dc) => [dr, dc] },
  // Right-E -> Back: Right(0,1)->Back(0,0), Right(1,1)->Back(1,0)
  '2,E': { toFace: BACK, mapPos: r => [r, 0], mapDir: (dr, dc) => [dr, dc] },

  // === BACK face (3) edges ===
  // Back-N -> Top: Back(0,0)->Top(0,1), Back(0,1)->Top(0,0)
  '3,N': { toFace: TOP, mapPos: c => [0, 1 - c], mapDir: (dr, dc) => [-dr, -dc] },
  // Back-S -> Bottom: Back(1,0)->Bottom(1,1), Back(1,1)->Bottom(1,0)
  '3,S': { toFace: BOTTOM, mapPos: c => [1, 1 - c], mapDir: (dr, dc) => [-dr, -dc] },
  // Back-W -> Right: Back(0,0)->Right(0,1), Back(1,0)->Right(1,1)
  '3,W': { toFace: RIGHT, mapPos: r => [r, 1], mapDir: (dr, dc) => [dr, dc] },
  // Back-E -> Left: Back(0,1)->Left(0,0), Back(1,1)->Left(1,0)
  '3,E': { toFace: LEFT, mapPos: r => [r, 0], mapDir: (dr, dc) => [dr, dc] },

  // === LEFT face (4) edges ===
  // Left-N -> Top: Left(0,0)->Top(0,0), Left(0,1)->Top(1,0)
  '4,N': { toFace: TOP, mapPos: c => [c, 0], mapDir: (dr, dc) => [dc, -dr] },
  // Left-S -> Bottom: Left(1,0)->Bottom(1,0), Left(1,1)->Bottom(0,0)
  '4,S': { toFace: BOTTOM, mapPos: c => [1 - c, 0], mapDir: (dr, dc) => [-dc, dr] },
  // Left-W -> Back: Left(0,0)->Back(0,1), Left(1,0)->Back(1,1)
  '4,W': { toFace: BACK, mapPos: r => [r, 1], mapDir: (dr, dc) => [dr, dc] },
  // Left-E -> Front: Left(0,1)->Front(0,0), Left(1,1)->Front(1,0)
  '4,E': { toFace: FRONT, mapPos: r => [r, 0], mapDir: (dr, dc) => [dr, dc] },

  // === BOTTOM face (5) edges ===
  // Bottom-N -> Front: Bottom(0,0)->Front(1,0), Bottom(0,1)->Front(1,1)
  '5,N': { toFace: FRONT, mapPos: c => [1, c], mapDir: (dr, dc) => [dr, dc] },
  // Bottom-S -> Back: Bottom(1,0)->Back(1,1), Bottom(1,1)->Back(1,0)
  '5,S': { toFace: BACK, mapPos: c => [1, 1 - c], mapDir: (dr, dc) => [-dr, -dc] },
  // Bottom-W -> Left: Bottom(0,0)->Left(1,1), Bottom(1,0)->Left(1,0)
  '5,W': { toFace: LEFT, mapPos: r => [1, 1 - r], mapDir: (dr, dc) => [dc, -dr] },
  // Bottom-E -> Right: Bottom(0,1)->Right(1,0), Bottom(1,1)->Right(1,1)
  '5,E': { toFace: RIGHT, mapPos: r => [1, r], mapDir: (dr, dc) => [-dc, dr] },
};

// Get the edge and index for a cell going off a face boundary
function getEdgeInfo(row, col, dr, dc) {
  const nr = row + dr;
  const nc = col + dc;

  // Diagonal going off a corner (vertex of the cube) - terminate
  // Must check BEFORE single-edge checks
  if ((nr < 0 || nr > 1) && (nc < 0 || nc > 1)) return null;

  // Going off a single edge (works for both cardinal and diagonal)
  // idx = position along the shared edge on this face
  if (nr < 0) return { edge: 'N', idx: nc };
  if (nr > 1) return { edge: 'S', idx: nc };
  if (nc < 0) return { edge: 'W', idx: nr };
  if (nc > 1) return { edge: 'E', idx: nr };

  return null;
}

// Get the neighbor of a cell in a given direction.
// Returns { face, row, col, dr, dc } (with transformed direction) or null.
function getNeighbor(face, row, col, dr, dc) {
  const nr = row + dr;
  const nc = col + dc;

  // Stay on same face
  if (nr >= 0 && nr <= 1 && nc >= 0 && nc <= 1) {
    return { face, row: nr, col: nc, dr, dc };
  }

  // Going off the face - find edge transition
  const edgeInfo = getEdgeInfo(row, col, dr, dc);
  if (!edgeInfo) return null; // Vertex - terminate

  const key = face + ',' + edgeInfo.edge;
  const transition = EDGE_TRANSITIONS[key];
  if (!transition) return null;

  const [newRow, newCol] = transition.mapPos(edgeInfo.idx);
  const [newDr, newDc] = transition.mapDir(dr, dc);
  return { face: transition.toFace, row: newRow, col: newCol, dr: newDr, dc: newDc };
}

// Trace a line from (face, row, col) in direction (dr, dc), not including the starting cell.
// Returns array of { face, row, col }.
function traceLine(face, row, col, dr, dc) {
  const cells = [];
  let cur = { face, row, col, dr, dc };
  const startIdx = cellIndex(face, row, col);

  for (let i = 0; i < 10; i++) { // Safety limit
    const next = getNeighbor(cur.face, cur.row, cur.col, cur.dr, cur.dc);
    if (!next) break;
    // Stop if we've cycled back to the starting cell
    if (cellIndex(next.face, next.row, next.col) === startIdx) break;
    cells.push({ face: next.face, row: next.row, col: next.col });
    cur = next;
  }
  return cells;
}

// -------------------------------------------------------
// 2. GAME LOGIC
// -------------------------------------------------------

const BLACK = 'black';
const WHITE = 'white';

function opponent(color) {
  return color === BLACK ? WHITE : BLACK;
}

function cellIndex(face, row, col) {
  return face * 4 + row * 2 + col;
}

function fromIndex(idx) {
  const face = Math.floor(idx / 4);
  const rem = idx % 4;
  return { face, row: Math.floor(rem / 2), col: rem % 2 };
}

function createBoard() {
  return new Array(24).fill(null);
}

function cloneBoard(board) {
  return board.slice();
}

function getCell(board, face, row, col) {
  return board[cellIndex(face, row, col)];
}

function setCell(board, face, row, col, val) {
  board[cellIndex(face, row, col)] = val;
}

// Initial setup: 4 pieces in a standard Othello pattern on the Front face
function initBoard() {
  const board = createBoard();
  // Front face (1):
  //   (0,0)=white  (0,1)=black
  //   (1,0)=black  (1,1)=white
  setCell(board, FRONT, 0, 0, WHITE);
  setCell(board, FRONT, 0, 1, BLACK);
  setCell(board, FRONT, 1, 0, BLACK);
  setCell(board, FRONT, 1, 1, WHITE);
  return board;
}

// Get flips for placing 'color' at (face, row, col)
function getFlips(board, face, row, col, color) {
  if (getCell(board, face, row, col) !== null) return [];

  const opp = opponent(color);
  const allFlips = [];

  for (const [dr, dc] of DIRS) {
    const line = traceLine(face, row, col, dr, dc);
    const flips = [];
    for (const cell of line) {
      const val = getCell(board, cell.face, cell.row, cell.col);
      if (val === opp) {
        flips.push(cell);
      } else if (val === color) {
        // Found our piece - these flips are valid
        allFlips.push(...flips);
        break;
      } else {
        // Empty cell - no flips in this direction
        break;
      }
    }
  }
  return allFlips;
}

function getValidMoves(board, color) {
  const moves = [];
  for (let i = 0; i < 24; i++) {
    if (board[i] !== null) continue;
    const { face, row, col } = fromIndex(i);
    const flips = getFlips(board, face, row, col, color);
    if (flips.length > 0) {
      moves.push({ face, row, col, flips });
    }
  }
  return moves;
}

function makeMove(board, face, row, col, color) {
  const newBoard = cloneBoard(board);
  const flips = getFlips(board, face, row, col, color);
  setCell(newBoard, face, row, col, color);
  for (const f of flips) {
    setCell(newBoard, f.face, f.row, f.col, color);
  }
  return { board: newBoard, flips };
}

function countPieces(board) {
  let black = 0, white = 0;
  for (const cell of board) {
    if (cell === BLACK) black++;
    if (cell === WHITE) white++;
  }
  return { black, white };
}

// -------------------------------------------------------
// 3. AI ENGINE
// -------------------------------------------------------

// Positional weights: corners of each face are most valuable
// Face cells: (0,0), (0,1), (1,0), (1,1)
// All cells on a 2x2 face are effectively corners of that face,
// but they differ in how many cross-face lines pass through them.
// Give slight bonus to cells with more adjacencies.
const POSITION_WEIGHTS = new Array(24).fill(0);
// Each cell's weight is 1 (base) + bonus based on topology
(function computeWeights() {
  for (let i = 0; i < 24; i++) {
    const { face, row, col } = fromIndex(i);
    let count = 0;
    for (const [dr, dc] of DIRS) {
      const n = getNeighbor(face, row, col, dr, dc);
      if (n) count++;
    }
    // Cells with more neighbors (cross-face connections) are strategically more valuable
    POSITION_WEIGHTS[i] = count;
  }
})();

function evaluate(board, aiColor) {
  const playerColor = opponent(aiColor);
  let score = 0;

  // Piece count and position
  for (let i = 0; i < 24; i++) {
    if (board[i] === aiColor) score += 10 + POSITION_WEIGHTS[i];
    else if (board[i] === playerColor) score -= 10 + POSITION_WEIGHTS[i];
  }

  // Mobility (number of valid moves)
  const aiMoves = getValidMoves(board, aiColor).length;
  const playerMoves = getValidMoves(board, playerColor).length;
  score += (aiMoves - playerMoves) * 5;

  return score;
}

function minimax(board, depth, alpha, beta, isMaximizing, aiColor) {
  const playerColor = opponent(aiColor);
  const currentColor = isMaximizing ? aiColor : playerColor;
  const moves = getValidMoves(board, currentColor);

  // Terminal conditions
  if (depth === 0) return evaluate(board, aiColor);

  if (moves.length === 0) {
    // Check if opponent also has no moves (game over)
    const oppMoves = getValidMoves(board, opponent(currentColor));
    if (oppMoves.length === 0) {
      // Game over - evaluate final state heavily
      const { black, white } = countPieces(board);
      const aiCount = aiColor === BLACK ? black : white;
      const playerCount = aiColor === BLACK ? white : black;
      if (aiCount > playerCount) return 1000 + aiCount - playerCount;
      if (playerCount > aiCount) return -1000 - playerCount + aiCount;
      return 0;
    }
    // Pass turn
    return minimax(board, depth - 1, alpha, beta, !isMaximizing, aiColor);
  }

  if (isMaximizing) {
    let maxEval = -Infinity;
    for (const move of moves) {
      const { board: newBoard } = makeMove(board, move.face, move.row, move.col, currentColor);
      const ev = minimax(newBoard, depth - 1, alpha, beta, false, aiColor);
      maxEval = Math.max(maxEval, ev);
      alpha = Math.max(alpha, ev);
      if (beta <= alpha) break;
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for (const move of moves) {
      const { board: newBoard } = makeMove(board, move.face, move.row, move.col, currentColor);
      const ev = minimax(newBoard, depth - 1, alpha, beta, true, aiColor);
      minEval = Math.min(minEval, ev);
      beta = Math.min(beta, ev);
      if (beta <= alpha) break;
    }
    return minEval;
  }
}

function getBestMove(board, aiColor) {
  const moves = getValidMoves(board, aiColor);
  if (moves.length === 0) return null;

  let bestMove = moves[0];
  let bestScore = -Infinity;

  // Use deeper search since board is small
  const depth = 8;

  for (const move of moves) {
    const { board: newBoard } = makeMove(board, move.face, move.row, move.col, aiColor);
    const score = minimax(newBoard, depth - 1, -Infinity, Infinity, false, aiColor);
    if (score > bestScore) {
      bestScore = score;
      bestMove = move;
    }
  }
  return bestMove;
}

// -------------------------------------------------------
// 4. RENDERING
// -------------------------------------------------------

const cubeEl = document.getElementById('cube');
const sceneEl = document.getElementById('scene');

// -------------------------------------------------------
// RESPONSIVE SIZING
// -------------------------------------------------------
function resizeCube() {
  const sceneRect = sceneEl.getBoundingClientRect();
  const available = Math.min(sceneRect.width, sceneRect.height);
  // キューブの見た目サイズは利用可能領域の45%程度（回転時にはみ出さないよう）
  const faceSize = Math.max(100, Math.floor(available * 0.45));
  const half = faceSize / 2;

  cubeEl.style.width = faceSize + 'px';
  cubeEl.style.height = faceSize + 'px';
  cubeEl.style.setProperty('--face-size', faceSize + 'px');
  cubeEl.style.setProperty('--half-face', half + 'px');
}

window.addEventListener('resize', resizeCube);
window.addEventListener('orientationchange', () => setTimeout(resizeCube, 200));

const FACE_CLASSES = ['face-top', 'face-front', 'face-right', 'face-back', 'face-left', 'face-bottom'];
let cellElements = []; // indexed by cellIndex

function buildCube() {
  cubeEl.innerHTML = '';
  cellElements = new Array(24);

  for (let f = 0; f < 6; f++) {
    const faceDiv = document.createElement('div');
    faceDiv.className = 'face ' + FACE_CLASSES[f];

    for (let r = 0; r < 2; r++) {
      for (let c = 0; c < 2; c++) {
        const cellDiv = document.createElement('div');
        cellDiv.className = 'cell';
        cellDiv.dataset.face = f;
        cellDiv.dataset.row = r;
        cellDiv.dataset.col = c;
        cellDiv.addEventListener('click', onCellClick);
        faceDiv.appendChild(cellDiv);
        cellElements[cellIndex(f, r, c)] = cellDiv;
      }
    }

    cubeEl.appendChild(faceDiv);
  }
}

function renderBoard(board, validMoves) {
  const validSet = new Set(validMoves ? validMoves.map(m => cellIndex(m.face, m.row, m.col)) : []);

  for (let i = 0; i < 24; i++) {
    const cellDiv = cellElements[i];
    cellDiv.innerHTML = '';

    if (validSet.has(i)) {
      cellDiv.classList.add('clickable');
      const marker = document.createElement('div');
      marker.className = 'valid-marker';
      cellDiv.appendChild(marker);
    } else {
      cellDiv.classList.remove('clickable');
      if (board[i]) {
        const piece = document.createElement('div');
        piece.className = 'piece ' + board[i];
        cellDiv.appendChild(piece);
      }
    }
  }

  // Update scores
  const counts = countPieces(board);
  document.getElementById('score-black').textContent = counts.black;
  document.getElementById('score-white').textContent = counts.white;
}

function animateFlips(flips, color, callback) {
  if (flips.length === 0) {
    callback();
    return;
  }

  let completed = 0;
  for (const f of flips) {
    const idx = cellIndex(f.face, f.row, f.col);
    const piece = cellElements[idx].querySelector('.piece');
    if (piece) {
      piece.classList.add('flipping');
      setTimeout(() => {
        piece.className = 'piece ' + color;
      }, 200);
      setTimeout(() => {
        piece.classList.remove('flipping');
        completed++;
        if (completed === flips.length) callback();
      }, 400);
    } else {
      completed++;
      if (completed === flips.length) callback();
    }
  }
}

// -------------------------------------------------------
// 5. ROTATION CONTROLS
// -------------------------------------------------------

let rotX = -25, rotY = 35;
let isDragging = false;
let dragStartX, dragStartY;
let dragMoved = false;

function updateCubeTransform() {
  cubeEl.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg)`;
}

sceneEl.addEventListener('mousedown', e => {
  isDragging = true;
  dragMoved = false;
  dragStartX = e.clientX;
  dragStartY = e.clientY;
});

document.addEventListener('mousemove', e => {
  if (!isDragging) return;
  const dx = e.clientX - dragStartX;
  const dy = e.clientY - dragStartY;
  if (Math.abs(dx) > 3 || Math.abs(dy) > 3) dragMoved = true;
  rotY += dx * 0.5;
  rotX -= dy * 0.5;
  dragStartX = e.clientX;
  dragStartY = e.clientY;
  updateCubeTransform();
});

document.addEventListener('mouseup', () => { isDragging = false; });

// Touch support（preventDefaultでスクロール・バウンスを防止）
sceneEl.addEventListener('touchstart', e => {
  e.preventDefault();
  isDragging = true;
  dragMoved = false;
  dragStartX = e.touches[0].clientX;
  dragStartY = e.touches[0].clientY;
}, { passive: false });

document.addEventListener('touchmove', e => {
  if (!isDragging) return;
  e.preventDefault();
  const dx = e.touches[0].clientX - dragStartX;
  const dy = e.touches[0].clientY - dragStartY;
  if (Math.abs(dx) > 3 || Math.abs(dy) > 3) dragMoved = true;
  rotY += dx * 0.5;
  rotX -= dy * 0.5;
  dragStartX = e.touches[0].clientX;
  dragStartY = e.touches[0].clientY;
  updateCubeTransform();
}, { passive: false });

document.addEventListener('touchend', () => { isDragging = false; });

// -------------------------------------------------------
// 6. GAME FLOW
// -------------------------------------------------------

let board = initBoard();
let currentTurn = BLACK;
let gameOver = false;
let isAnimating = false;

const turnIndicator = document.getElementById('turn-indicator');
const messageEl = document.getElementById('message');

function setMessage(msg) {
  messageEl.textContent = msg;
}

function updateTurnDisplay() {
  if (gameOver) return;
  if (currentTurn === BLACK) {
    turnIndicator.textContent = 'あなたの番';
    turnIndicator.style.color = '#e94560';
  } else {
    turnIndicator.textContent = 'CPU 思考中...';
    turnIndicator.style.color = '#4fc3f7';
  }
}

function checkGameOver() {
  const blackMoves = getValidMoves(board, BLACK);
  const whiteMoves = getValidMoves(board, WHITE);

  if (blackMoves.length === 0 && whiteMoves.length === 0) {
    gameOver = true;
    const counts = countPieces(board);
    if (counts.black > counts.white) {
      turnIndicator.textContent = 'あなたの勝ち!';
      turnIndicator.style.color = '#4caf50';
      setMessage(`${counts.black} - ${counts.white}`);
    } else if (counts.white > counts.black) {
      turnIndicator.textContent = 'CPU の勝ち!';
      turnIndicator.style.color = '#e94560';
      setMessage(`${counts.black} - ${counts.white}`);
    } else {
      turnIndicator.textContent = '引き分け!';
      turnIndicator.style.color = '#ffd700';
      setMessage(`${counts.black} - ${counts.white}`);
    }
    renderBoard(board, []);
    return true;
  }

  return false;
}

function switchTurn() {
  currentTurn = opponent(currentTurn);

  if (checkGameOver()) return;

  const moves = getValidMoves(board, currentTurn);
  if (moves.length === 0) {
    setMessage((currentTurn === BLACK ? 'あなた' : 'CPU') + 'は置ける場所がありません。パスします。');
    currentTurn = opponent(currentTurn);
    if (checkGameOver()) return;
  }

  updateTurnDisplay();

  if (currentTurn === BLACK) {
    const validMoves = getValidMoves(board, BLACK);
    renderBoard(board, validMoves);
  } else {
    renderBoard(board, []);
    // AI turn
    setTimeout(doAITurn, 300);
  }
}

function doAITurn() {
  if (gameOver) return;
  const move = getBestMove(board, WHITE);
  if (!move) {
    switchTurn();
    return;
  }

  // Place piece
  const { board: newBoard, flips } = makeMove(board, move.face, move.row, move.col, WHITE);

  // Show the placed piece first
  setCell(board, move.face, move.row, move.col, WHITE);
  renderBoard(board, []);

  // Animate flips
  isAnimating = true;
  animateFlips(flips, WHITE, () => {
    board = newBoard;
    renderBoard(board, []);
    isAnimating = false;
    setMessage('');
    switchTurn();
  });
}

function onCellClick(e) {
  if (gameOver || isAnimating || currentTurn !== BLACK) return;
  if (dragMoved) return; // Was a drag, not a click

  const cellDiv = e.currentTarget;
  const face = parseInt(cellDiv.dataset.face);
  const row = parseInt(cellDiv.dataset.row);
  const col = parseInt(cellDiv.dataset.col);

  const flips = getFlips(board, face, row, col, BLACK);
  if (flips.length === 0) return; // Not a valid move

  // Make the move
  const { board: newBoard } = makeMove(board, face, row, col, BLACK);

  // Show placed piece
  setCell(board, face, row, col, BLACK);
  renderBoard(board, []);

  // Animate flips
  isAnimating = true;
  animateFlips(flips, BLACK, () => {
    board = newBoard;
    renderBoard(board, []);
    isAnimating = false;
    setMessage('');
    switchTurn();
  });
}

function startGame() {
  board = initBoard();
  currentTurn = BLACK;
  gameOver = false;
  isAnimating = false;
  setMessage('');
  updateTurnDisplay();
  const validMoves = getValidMoves(board, BLACK);
  renderBoard(board, validMoves);
}

// Button handlers
document.getElementById('btn-new').addEventListener('click', startGame);
document.getElementById('btn-reset-view').addEventListener('click', () => {
  rotX = -25;
  rotY = 35;
  updateCubeTransform();
});

// Initialize
buildCube();
resizeCube();
updateCubeTransform();
startGame();
</script>
</body>
</html>
